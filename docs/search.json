[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "R para Ciência de Dados (2e) - Soluções dos Exercícios",
    "section": "",
    "text": "Bem-vindo\nEste site refere-se a possíveis Soluções dos Exercícios da versão traduzida da 2ª edição do livro “R para Ciência de Dados”.",
    "crumbs": [
      "Bem-vindo"
    ]
  },
  {
    "objectID": "EDA.html",
    "href": "EDA.html",
    "title": "\n2  Análise exploratória de dados\n",
    "section": "",
    "text": "2.1 Pré-requisitos\nlibrary(tidyverse)\nlibrary(dados)",
    "crumbs": [
      "Visualizar",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Análise exploratória de dados</span>"
    ]
  },
  {
    "objectID": "EDA.html#variação",
    "href": "EDA.html#variação",
    "title": "\n2  Análise exploratória de dados\n",
    "section": "\n2.2 Variação",
    "text": "2.2 Variação\n\nExplore a distribuição das variáveis x, y, and z em diamantes. O que você aprendeu? Pense em um diamante e como você pode decidir qual dimensão é o comprimento, largura e profundidade.\n\nResolução: Inicialmente, vamos gerar os histogramas de cada uma das dimensões para melhor compreender cada uma.\n\ndiamante |&gt; \n  dplyr::select(c(x, y, z)) |&gt;\n  tidyr::pivot_longer(\n    cols = tidyr::everything(),\n    names_to = \"variavel\",\n    values_to = \"valor\"\n  ) |&gt; \n  ggplot(\n    mapping = aes(x = valor)\n  ) +\n  geom_histogram(binwidth = 0.5) +\n  facet_wrap(vars(variavel), \n             ncol = 3, \n             scales = \"free\",\n             strip.position = \"bottom\") +\n  theme_minimal() +\n  theme(\n    strip.placement = \"outside\",\n    axis.title.x = element_blank()\n  ) + \n  labs(y = \"frequência\")\n\n\n\n\n\n\n\nVisualizando os histogramas de cada das dimensões, é possível perceber que as dimensões são positivamente distribuídas (\\(x &gt;= 0\\), \\(y &gt;= 0\\) e \\(z &gt;= 0\\)), mas que há outliers, isto é, valores atípicos nas caudas inferior e superior das distribuições (hipótese esta sugerida devido aos limites amplos no eixo x dos gráficos).\nPara visualizar melhor os valores típicos de cada dimensão, geraremos novamente os histogramas. Mas, desta vez, com um zoom em uma região de interesse.\n\ndiamante |&gt; \n  dplyr::select(c(x, y, z)) |&gt;\n  tidyr::pivot_longer(\n    cols = tidyr::everything(),\n    names_to = \"variavel\",\n    values_to = \"valor\"\n  ) |&gt; \n  ggplot(\n    mapping = aes(x = valor)\n  ) +\n  geom_histogram(binwidth = 0.5) +\n  facet_wrap(vars(variavel), \n             ncol = 3, \n             scales = \"free\",\n             strip.position = \"bottom\") +\n  theme_minimal() +\n  theme(\n    strip.placement = \"outside\",\n    axis.title.x = element_blank()\n  ) + \n  labs(y = \"frequência\") +\n  coord_cartesian(xlim = c(2.5, 9))\n\n\n\n\n\n\n\nAgora, com esta última visualização, podemos perceber que, em geral, o comprimento (x) e a largura (y) dos diamantes dessa base de dados são mais similares, enquanto que a profundidade (z) parece ser menor.\n\nExplore a distribuição de preço. Você percebe algo incomum ou surpreendente? (Dica: pense cuidadosamente sobre o binwidth e tenha certeza que você tentou uma ampla gama de valores.)\n\nResolução: Inicialmente, vamos gerar o histograma da variável preco para tentar compreender sua distribuição, mas sem alterar o parâmetro binwidth.\n\nggplot(\n  data = diamante,\n  mapping = aes(x = preco)\n) +\n  geom_histogram() +\n  theme_minimal() +\n  labs(x = \"preço (US$)\", y = \"frequência\")\n#&gt; `stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\n\n\nO histograma gerado sugere que a distribuição de preços é assimétrica à direita. Isso significa que a maioria dos diamantes possui preços concentrados em faixas mais baixas, criando um pico pronunciado na parte inicial da distribuição. No entanto, há uma cauda longa estendendo-se para valores mais altos, indicando a presença de alguns diamantes com preços extremamente elevados.\nAgora, vamos explorar diferentes valores de binwidth para verificar se conseguimos identificar algum padrão ou detalhe que possa estar passando despercebido.\nEntretanto, uma questão crucial que surge é: como determinar os valores ideais para binwidth?\nA escolha do valor de binwidth é uma parte crucial ao criar histogramas, pois afeta como a variável de interesse será visualizada e interpretada. Mas, não existe uma abordagem única para determinar o valor ideal para binwidth.\nSe você tiver interessado no assunto, pode pesquisar mais sobre Regra de Sturges, Regra de Scott e Regra de Freedman-Diaconis a fim de obter uma visão mais formal da estatística por trás do assunto.\nAqui, será apresentada uma abordagem mais empírica para o tema, por meio da experimentação e visualização.\nPara tanto, vamos explorar valores pequenos e grandes de binwidth para tentar compreender, na prática, como o binwidth afeta a interpretação do histograma.\n\nbinwidths &lt;- c(\n  seq(from = 0.05, to = 2.5, by = 0.5),\n  seq(from = 5, to = 100, by = 10),\n  seq(from = 500, to = 1500, by = 250),\n  15000\n)\n\npurrr::map(binwidths, \\(bw){\n  ggplot(\n    data = diamante,\n    mapping = aes(x = preco)\n  ) +\n    geom_histogram(binwidth = bw) +\n    theme_minimal() +\n    labs(\n      title = glue::glue(\"binwidth = {bw}\"),\n      x = \"preço (US$)\",\n      y = \"frequência\"\n    )\n})\n#&gt; [[1]]\n#&gt; \n#&gt; [[2]]\n#&gt; \n#&gt; [[3]]\n#&gt; \n#&gt; [[4]]\n#&gt; \n#&gt; [[5]]\n#&gt; \n#&gt; [[6]]\n#&gt; \n#&gt; [[7]]\n#&gt; \n#&gt; [[8]]\n#&gt; \n#&gt; [[9]]\n#&gt; \n#&gt; [[10]]\n#&gt; \n#&gt; [[11]]\n#&gt; \n#&gt; [[12]]\n#&gt; \n#&gt; [[13]]\n#&gt; \n#&gt; [[14]]\n#&gt; \n#&gt; [[15]]\n#&gt; \n#&gt; [[16]]\n#&gt; \n#&gt; [[17]]\n#&gt; \n#&gt; [[18]]\n#&gt; \n#&gt; [[19]]\n#&gt; \n#&gt; [[20]]\n#&gt; \n#&gt; [[21]]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nQuando o valor de binwidth é excessivamente pequeno, o histograma passa a refletir a frequência de cada valor individual, sem proporcionar uma visualização agrupada por classes, o que dificulta uma interpretação mais generalizada. Por outro lado, quando o binwidth é demasiadamente grande, os dados são agrupados em poucas classes, o que pode ocultar detalhes importantes ou, em casos extremos, levar a interpretações equivocadas (observe o caso em que binwidth = 15.000). Por tanto, um binwidth inadequado pode ocultar padrões importantes ou criar padrões artificiais.\nMas, quando variamos os valores de binwidth entre 5 e 75, percebemos algo curioso. Em torno de US$ 1.500, há uma lacuna no histograma, sugerindo que, portanto, não há diamantes com preços em torno de US$ 1.500,00.\n\nQuantos diamantes equivalem a 0,99 quilates? Quantos equivalem a 1 quilate? O que você acha que é a causa da diferença?\n\nResolução: Inicialmente, vamos gerar o histograma, dando um zoom próximo a esses valores.\n\nggplot(\n  data = diamante,\n  mapping = aes(x = quilate)\n) +\n  geom_histogram(binwidth = 0.01) +\n  theme_minimal() +\n  labs(\n    x = \"quilate (ct)\",\n    y = \"frequência\"\n  ) + \n  coord_cartesian(xlim = c(0.97, 1.02))\n\n\n\n\n\n\n\nNa base de dados, havia mais diamantes com exatamente 1 quilate do que com 0,99 quilates. Essa diferença pode ser explicada por fatores comerciais, já que o peso da pedra impacta diretamente em seu valor e, para além disso, o preço tende a aumentar significativamente quando o peso atinge um peso crítico, como 1 quilate, devido ao apelo psicológico e ao valor de mercado associado a esse peso simbólico.\n\nCompare e contraste coord_cartesian() vs. xlim() ou ylim() quando fizer uma ampliação em um histograma. O que acontece se você deixa o binwidth desativado? O que acontece se você tentar ampliar de forma que apenas meia barra seja exibida?\n\nResolução: Quando as funções xlim() ou ylim() são utilizadas, os dados que não pertencem ao intervalo especificado são removidos. Em outras palavras, isso significa que as funções xlim() e ylim() realizam primeiro uma filtragem dos dados, removendo aqueles fora do intervalo especificado, para só então gerar o gráfico propriamente dito. Isso, no entanto, pode afetar a estimativa de frequência das classes do histograma, já que os demais dados são removidos. Diferentemente dessas duas funções, a coord_cartesian() permite ampliar uma área no gráfico, mas sem remover os dados não contidos no intervalo de interesse, funcionando como um zoom na visualização.\nPodemos comparar este comportamento das funções nos gráficos abaixo.\n\nggplot(\n  data = diamante,\n  mapping = aes(x = quilate)\n) +\n  geom_histogram() +\n  theme_minimal() +\n  labs(\n    title = \"Usando a função coord_cartesian()\",\n    x = \"quilate (ct)\",\n    y = \"frequência\"\n  ) + \n  coord_cartesian(xlim = c(1.2, 1.40))\n#&gt; `stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\nggplot(\n  data = diamante,\n  mapping = aes(x = quilate)\n) +\n  geom_histogram() +\n  theme_minimal() +\n  labs(\n    title = \"Usando a função xlim()\",\n    x = \"quilate (ct)\",\n    y = \"frequência\"\n  ) + \n  xlim(c(1.2, 1.40))\n#&gt; `stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n#&gt; Warning: Removed 50549 rows containing non-finite outside the scale range\n#&gt; (`stat_bin()`).\n#&gt; Warning: Removed 2 rows containing missing values or values outside the scale range\n#&gt; (`geom_bar()`).\n\n\n\n\n\n\n\n\n\n\n\n\n\nAlém disso, observe que, no histograma em que foi utilizada a função coord_cartesian(), as barras correspondentes aos limites do intervalo definido permanecem visíveis no gráfico, enquanto que, no histograma em que foi utilizada a função xlim(), não.",
    "crumbs": [
      "Visualizar",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Análise exploratória de dados</span>"
    ]
  },
  {
    "objectID": "EDA.html#lidando-com-valores-atípicos",
    "href": "EDA.html#lidando-com-valores-atípicos",
    "title": "\n2  Análise exploratória de dados\n",
    "section": "\n2.3 Lidando com valores atípicos",
    "text": "2.3 Lidando com valores atípicos\n\nO que acontece com valores ausentes em um histograma? O que acontece com valores ausentes em um gráfico de barras? Por que existe uma diferença em como valores ausentes são tratados em histogramas e gráficos de barras?\n\nResolução: Os valores ausentes (NA) são tratados de maneira diferente em histogramas e gráficos de barras devido à natureza dos dados que cada tipo de gráfico representa.\nNo histograma, valores ausentes não são incluídos no cálculo das frequências das classes e também não são apresentados graficamente, pois não representam nenhuma classe.\nObserve a mensagem ao gerar o histograma no exemplo abaixo.\n\n# transformando, em `NA`, os valores \"estranhos\" de `y`\ndiamante2 &lt;- diamante |&gt; \n  dplyr::mutate(\n    y = dplyr::if_else(dplyr::between(y, 3, 20), y, NA)\n  )\n\n# gerando o histograma para a variável `y`\ndiamante2 |&gt; \n  ggplot(aes(x = y)) + \n  geom_histogram(binwidth = 0.1) +\n  theme_minimal()\n#&gt; Warning: Removed 9 rows containing non-finite outside the scale range\n#&gt; (`stat_bin()`).\n\n\n\n\n\n\n\nPor outro lado, no gráfico de barras, os valores ausentes são considerados, por padrão, como uma das categorias e são apresentados graficamente como a frequência de ocorrência de NAs.\nNo exemplo abaixo, NAa são introduzidos na variável corte para demonstrar como valores faltantes são apresentados em um gráfico de barras.\n\n# transformando, em `NA`, as categorias do corte nas observações em que `y` não está entre 3 e 20\ndiamante2 &lt;- diamante |&gt; \n  dplyr::mutate(\n    corte = dplyr::if_else(dplyr::between(y, 3, 20), corte, NA)\n  )\n\n# gerando o gráfico de barra para a variável `corte`\ndiamante2 |&gt;\n  ggplot(aes(x = corte)) + \n  geom_bar() +\n  theme_minimal()\n\n# gerando o gráfico de barra para a variável `corte` com um zoom para ver melhor a barra referente aos valores faltantes\ndiamante2 |&gt;\n  ggplot(aes(x = corte)) + \n  geom_bar() + \n  coord_cartesian(ylim = c(0, 10)) +\n  theme_minimal()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nO que significa o na.rm = TRUE em mean() e sum()?\n\nResolução: Quando é usado na.rm = TRUE nas funções mean() e sum(), estamos indicando para estas funções que os valores ausentes (NA) devem ser removidos antes de serem realizados os cálculos.\nQuando na.rm = FALSE e há valores faltantes na sequência, as funções retornam NA como resultado. Já quando na.rm = TRUE e há valores faltantes na sequência, as funções, primeiramente, eliminam os NAs e, depois, realizam os cálculos.\nNa prática, podemos comparar os resultados de quando na.rm é definido como FALSE (default) e TRUE, por exemplo, ao estimar a média do conjunto \\(\\{1, 2, 3, 4, NA\\}\\).\n\n# criando um conjunto que apresenta NA\nconjunto_com_na &lt;- c(1:4, NA)\n\n# estimando a média com `na.rm = FALSE`\nmean(conjunto_com_na)\n#&gt; [1] NA\n\n# estimando a média com `na.rm = TRUE`\nmean(conjunto_com_na, na.rm = TRUE)\n#&gt; [1] 2.5\n\n\nRecrie o gráfico de frequência de saida_programada colorido de acordo com o voo ter sido cancelado ou não. Também use o facetamento para a variável cancelado. Experimente diferentes valores do argumento scales na função de facetamento para mitigar o efeito de mais voos não cancelados do que voos cancelados.\n\nResolução: Para conseguir ver a distribuição de cada categoria, tendo em vista que uma das categorias (a categoria referente aos voos não cancelados) tem muito mais voos do que outra (a categoria referente aos voos não cancelados), podemos gerar subgráficos para cada nível da variável cancelado, deixando que o eixo y, o qual expressa a frequência, seja ajustado individualmente para cada um.\n\nvoos2 &lt;- voos |&gt;\n  dplyr::mutate(\n    cancelado = is.na(horario_saida),\n    hora_programada = saida_programada %/% 100,\n    min_programado = saida_programada %% 100,\n    saida_programada_em_hora = hora_programada + (min_programado / 60)\n  ) \n\nvoos2 |&gt;\n  dplyr::mutate(\n    cancelado = dplyr::if_else(cancelado == TRUE, \"cancelado\", \"não cancelado\"),\n    cancelado = forcats::as_factor(cancelado)\n  ) |&gt;\n  ggplot(aes(x = saida_programada_em_hora, color = cancelado)) + \n  geom_freqpoly(binwidth = 0.25) + \n  facet_wrap(vars(cancelado), ncol = 1, scales = \"free_y\") +\n  labs(x = \"saída programada (horas)\", y = \"frequência\") + \n  theme(legend.position = \"none\")  +\n  theme_minimal()",
    "crumbs": [
      "Visualizar",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Análise exploratória de dados</span>"
    ]
  },
  {
    "objectID": "EDA.html#covariação",
    "href": "EDA.html#covariação",
    "title": "\n2  Análise exploratória de dados\n",
    "section": "\n2.4 Covariação",
    "text": "2.4 Covariação\n\n2.4.1 Uma variável categórica e uma numérica\n\nUse o que você aprendeu para melhorar a visualização dos horários de partida de voos cancelados e não cancelados.\n\nResolução:\n\ndados::voos |&gt;\n  dplyr::mutate(\n    cancelado = is.na(horario_saida),\n    cancelado = dplyr::if_else(cancelado == TRUE, \"cancelado\", \"não cancelado\"),\n    hora_programada = saida_programada %/% 100,\n    min_programado = saida_programada %% 100,\n    saida_programada = hora_programada + (min_programado / 60)\n  ) |&gt;\n  ggplot(\n    aes(x = forcats::fct_reorder(cancelado, saida_programada), y = saida_programada)\n  ) +\n  geom_boxplot() +\n  labs(x = \"\", y = \"saída programada\") +\n  theme_minimal()\n\n\n\n\n\n\n\n\nCom base na EDA, qual variável do banco de dados diamante parece ser mais importante para predizer o preço de um diamante? Como essa variável está correlacionada com corte? Por que a combinação dessas duas relações resulta em diamantes de pior qualidade terem preços mais elevados?\n\nResolução: Para visualizar as relações entre a variável preco e as demais variáveis númericas, podemos usar um pair plot que, além de gerar gráficos de dispersão, também estima a correlação entre as variáveis.\n\nlibrary(GGally)\n\nggpairs(diamante, columns = c(1:2, 6:10)) +\n  theme_minimal()\n\n\n\n\n\n\n\nEmbora as dimensões do diamanete pareçam ser importantes para predizer o preço, o quilate é a variável mais importante para predizer o preço. Observe que, à medida que o quilate aumenta, o preço aumenta de forma exponencial. Além disso, a análise de correlação confirma essa tendência, evidenciando uma relação forte entre o quilate e o preço do diamante.\nComo há muitos pontos, podemos gerar um boxplot agrupando os valores de quilate, assim como vimos anteriormente no capítulo.\n\nggplot(\n  diamante,\n  aes(x = quilate, y = preco)\n) +\n  geom_boxplot(aes(group = cut_width(quilate, 0.1))) +\n  labs(x = \"quilate (ct)\",\n       y = \"preço (US$)\") +\n  theme_minimal()\n\n\n\n\n\n\n\nAgora, vamos investigar como o valor do quilate se correlaciona com corte.\n\nggplot(data = diamante,\n       mapping = aes(\n         x = corte,\n         y = quilate\n       )) + \n  geom_boxplot() + \n  labs(x = \"\", y = \"quilate (ct)\") +\n  theme_minimal()\n\n\n\n\n\n\n\nA variável corte representa a qualidade da lapidação do diamante, em que justo é pior que bom, que, por sua vez, é pior que muito bom e assim por diante.\nObservamos que diamantes com quilates mais altos tendem a ter qualidade de corte mais baixa (i.e., justo), enquanto que diamantes com qualidade de corte superior (i.e., ideal) tendem a terem menores valores de quilate.\nTendo em vista essas duas relações, uma possível explicação para que diamantes com pior qualidade de corte terem preços mais elevados pode ser o fato da associação entre preço e quilate ser mais forte. Isso provavelmente porque, como diamantes maiores são mais raros e a demanda por eles é maior, seus preços aumentam mais do que a potencial “desvalorização” por ter uma lapidação de qualidade inferior.\n\nAo invés de trocar as variáveis x e y, adicione coord_flip() como uma nova camada para transformar o boxplot de vertical para horizontal. Como isso se compara à troca de variáveis?\n\nResolução: Anteriormente, criamos boxplots trocando os eixos x e y. Agora, vamos usar coord_flip().\n\nggplot(milhas, \n       aes(x = forcats::fct_reorder(classe, rodovia, median), y = rodovia)) +\n  geom_boxplot() +\n  theme_minimal() + \n  labs(x = \"\", y = \"milhas rodoviárias por galão\") +\n  coord_flip()\n\n\n\n\n\n\n\nA função coord_flip(), portanto, permite obter uma representação rotacionada sem ter que alterar manualmente as variáveis nos eixos.\n\nUm problema com os boxplots é que eles foram desenvolvidos em uma era de conjuntos de dados muito menores e tendem a exibir um número proibitivamente grande de “valores discrepantes”. Uma abordagem para remediar esse problema é o gráfico de valores de letras. Instale o pacote lvplot, e tente usar geom_lv() para exibir a distribuição de preço vs. corte. O que você entende? Como você interpreta os gráficos?\n\nResolução: Um letter value plot é uma alternativa ao boxplot tradicional, especialmente útil para grandes conjuntos de dados.\n\nlibrary(lvplot)\n\nggplot(diamante, aes(x = corte, y = preco)) +\n  geom_lv() +\n  labs(x = \"\", y = \"preço (US$)\") +\n  theme_minimal()\n\n\n\n\n\n\n\nÉ possível observar que diamantes de corte justo apresentam uma maior dispersão de preços. Além disso, diamantes com cortes de maior qualidade (i.e., ideal) geralmente possuem preços medianos menores.\n\nCrie uma visualização dos preços dos diamantes vs. uma variável categórica do banco de dados diamante usando o geom_violin(), depois um geom_histogram() facetado, e depois um geom_freqpoly() colorido, e então um geom_density() colorido. Compare e contraste os quatro gráficos. Quais são os prós e contras de cada método de visualização da distribuição de uma variável numérica baseada nos níveis de uma variável categórica?\n\nResolução: Vamos visualizar a distribuição dos preços dos diamantes em relação à qualidade do corte por diferentes tipos de visualização.\nGráfico de violino\nO gráfico de violino é uma combinação dos gráficos de densidade e boxplot. É uma representação interessante para visualizar a forma das distribuições e a variabilidade dos dados, mas pode tonar difícil a interpretação quando há muitas observações.\n\nggplot(diamante, aes(x = corte, y = preco)) +\n  geom_violin() +\n  labs(x = \"\", y = \"preço (US$)\") +\n  theme_minimal() +\n  coord_flip() \n\n\n\n\n\n\n\nHistograma\nO histograma é uma representação da distribuição dos dados, possibilitando a comparação de frequências absolutas e identificaão de assimetrias. No entanto, é uma representação dependente do tamanho das classes (i.e., bins).\n\nggplot(diamante, aes(x = preco)) +\n  geom_histogram(bins = 100) +\n  facet_wrap(vars(corte), scales = \"free_y\", ncol = 1) +\n  labs(x = \"preço (US$)\",\n       y = \"frequência\") +\n  theme_minimal() \n\n\n\n\n\n\n\nGráfico de frequência\nO gráfico de frequência é uma alternativa ao histograma que traça linhas ao invés de barras. É uma representação boa para comparar diferentes categorias. No entanto, pode dificultar a interpretação quando há muitas categorias.\n\nggplot(diamante, aes(x = preco, y = after_stat(density))) + \n  geom_freqpoly(aes(color = corte), binwidth = 500) +\n  labs(x = \"preço (US$)\",\n       y = \"frequência\") +\n  theme_minimal() \n\n\n\n\n\n\n\nGráfico de densidade\nO gráfico de frequência é uma representação excelente para comparar distribuições e evidenciar padrões gerais, uma vez que suaviza variações nos dados. No entanto, pode subestimar ou superestimar densidades se a suavização for inadequada.\n\nggplot(diamante, aes(x = preco)) + \n  geom_density(aes(color = corte)) +\n  labs(x = \"preço (US$)\",\n       y = \"densidade\") +\n  theme_minimal() \n\n\n\n\n\n\n\n\nSe você tem um pequeno conjunto de dados, às vezes é útil usar geom_jitter() para evitar sobreposição dos pontos e visualizar mais facilmente a relação entre as variáveis contínuas e categóricas. O pacote ggbeeswarm disponibiliza vários métodos similares ao geom_jitter(). Liste-os e descreva brevemente o que cada um deles faz.\n\nResolução: O pacote ggbeeswarm oferece duas alternativas ao geom_jitter() do ggplot2, permitindo visualizar melhor a dispersão dos pontos ao evitar sobreposição.\n\n\ngeom_quasirandom(): distribui os pontos aleatoriamente ao longo do eixo categórico, permitindo uma melhor visualização de pontos sobrepostos. Ao empregar a função, podem ser definidos vários métodos diferentes para determinar como os pontos serão distribuídos.\n\n\nlibrary(ggbeeswarm)\n\n# default\nggplot(milhas, aes(x = classe, y = rodovia)) +\n  geom_quasirandom() +\n  labs(x = \"\",\n       y = \"milhas rodoviárias por galão\",\n       title = \"Método quasirandom\") +\n  theme_minimal()\n\n# pseudorandom\nggplot(milhas, aes(x = classe, y = rodovia)) +\n  geom_quasirandom(method = \"pseudorandom\") +\n  labs(x = \"\",\n       y = \"milhas rodoviárias por galão\",\n       title = \"Método pseudorandom\") +\n  theme_minimal()\n\n# maxout\nggplot(milhas, aes(x = classe, y = rodovia)) +\n  geom_quasirandom(method = \"maxout\") +\n  labs(x = \"\",\n       y = \"milhas rodoviárias por galão\",\n       title = \"Método maxout\") +\n  theme_minimal()\n\n# minout\nggplot(milhas, aes(x = classe, y = rodovia)) +\n  geom_quasirandom(method = \"minout\") +\n  labs(x = \"\",\n       y = \"milhas rodoviárias por galão\",\n       title = \"Método minout\") +\n  theme_minimal()\n\n# tukey\nggplot(milhas, aes(x = classe, y = rodovia)) +\n  geom_quasirandom(method = \"tukey\") +\n  labs(x = \"\",\n       y = \"milhas rodoviárias por galão\",\n       title = \"Método tukey\") +\n  theme_minimal()\n\n# tukeyDense\nggplot(milhas, aes(x = classe, y = rodovia)) +\n  geom_quasirandom(method = \"tukeyDense\") +\n  labs(x = \"\",\n       y = \"milhas rodoviárias por galão\",\n       title = \"Método tukeyDense\") +\n  theme_minimal()\n\n# smiley\nggplot(milhas, aes(x = classe, y = rodovia)) +\n  geom_quasirandom(method = \"smiley\") +\n  labs(x = \"\",\n       y = \"milhas rodoviárias por galão\",\n       title = \"Método smiley\") +\n  theme_minimal()\n\n# frowney\nggplot(milhas, aes(x = classe, y = rodovia)) +\n  geom_quasirandom(method = \"frowney\") +\n  labs(x = \"\",\n       y = \"milhas rodoviárias por galão\",\n       title = \"Método frowney\") +\n  theme_minimal()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ngeom_beeswarm(): organiza os pontos como um “enxame de abelhas” (beeswarm), agrupando-os mais próximos de modo a minimizar a sobreposição.\n\n\nggplot(milhas, aes(x = classe, y = rodovia)) +\n  geom_beeswarm() +\n  labs(x = \"\", y = \"milhas rodoviárias por galão\") +\n  theme_minimal()\n\n\n\n\n\n\n\n\n2.4.2 Duas variáveis categóricas\n\nComo você poderia redimensionar o conjunto de dados de contagem acima para mostrar mais claramente a distribuição do corte dentro da cor ou da cor dentro do corte?\n\nResolução: Para redimensionar o conjunto de dados de contagem no conjunto de dados de diamantes e visualizar melhor a distribuição do corte dentro da cor ou da cor dentro do corte, podemos normalizar as frequências calculando proporções em vez de frequências absolutas.\nPara mostrar a distribuição do corte dentro da cor, estimaremos a proporção de cada corte para cada cor.\n\ndiamante |&gt;\n  dplyr::count(cor, corte) |&gt;\n  dplyr::group_by(cor) |&gt;\n  dplyr::mutate(prop = n / sum(n)) |&gt; \n  ggplot(aes(x = cor, y = corte, fill = prop)) +\n  geom_tile() +\n  scale_fill_viridis_c() +\n  labs(fill = \"proporção\") +\n  theme_minimal()\n\n\n\n\n\n\n\nPara mostrar a distribuição da cor dentro do corte, estimaremos a proporção de cada cor para cada corte\n\ndiamante |&gt;\n  dplyr::count(corte, cor) |&gt;\n  dplyr::group_by(corte) |&gt;\n  dplyr::mutate(prop = n / sum(n)) |&gt; \n  ggplot(aes(x = corte, y = cor, fill = prop)) +\n  geom_tile() +\n  scale_fill_viridis_c() +\n  labs(fill = \"proporção\") +\n  theme_minimal()\n\n\n\n\n\n\n\n\nQue diferentes insights de dados você obtém com um gráfico de barras segmentado se a cor for mapeada para a estética x e o corte for mapeado para a estética de preenchimento? Calcule as contagens que se enquadram em cada um dos segmentos.\n\nResolução:\n\ndiamante2 &lt;- diamante |&gt;\n  dplyr::count(cor, corte) \n\ndiamante2 |&gt;\n  ggplot(aes(x = cor, y = n, fill = corte)) +\n  geom_col() +\n  labs(y = \"frequência\") +\n  theme_minimal()\n\n\n\n\n\n\n\n\nUse geom_tile() junto com dplyr para explorar como os atrasos médios nas partidas de voos variam de acordo com o destino e o mês do ano. O que torna o gráfico difícil de ler? Como você poderia melhorá-lo?\n\nResolução:\n\nvoos |&gt;\n  dplyr::group_by(mes, destino) |&gt;\n  dplyr::summarise(\n    atraso_medio = mean(atraso_saida, na.rm = TRUE),\n    .groups = \"drop\"\n  ) |&gt;\n  ggplot(\n    aes(x = factor(mes), y = destino, fill = atraso_medio)\n  ) +\n  geom_tile() +\n  scale_fill_viridis_c() +\n  labs(\n    x = \"mês\",\n    y = \"destino\",\n    fill = \"atraso \\nmédio (min)\"\n  ) +\n  theme_minimal()\n\n\n\n\n\n\n\nNesta visualização, como há muitos destinos, os nomes dos destinos ficam sobrepostos e a representação não fica fácil de interpretar. Além disso, para alguns destinos, há menos voos em alguns meses, o que pode tornar o mapa de calor enganoso.\nPara facilitar a interpretação, poderíamos concentrar a nossa atenção nos destinos com voos regulares, isto é, que têm cobertura de 12 meses. Neste caso, valores ausentes correspondem a aeroportos que não têm voos regulares por serem, provavelmente, a aeroportos de pequeno porte.\n\nvoos2 &lt;- voos |&gt;\n  dplyr::group_by(mes, destino) |&gt;\n  dplyr::summarise(\n    atraso_medio = mean(atraso_saida,\n                        na.rm = TRUE\n    ), \n    .groups = \"drop\"\n  ) |&gt;\n  dplyr::group_by(destino) |&gt;\n  dplyr::mutate(cobertura_mensal = dplyr::n()) |&gt;\n  dplyr::filter(cobertura_mensal == 12)\n\nAlém disso, podemos ordenar os destinos pelo maior atraso médio para tornar as tendências mais claras no mapa.\n\nvoos2 &lt;- voos2 |&gt;\n  dplyr::ungroup() |&gt;\n  dplyr::mutate(destino = reorder(destino, atraso_medio)) \n\nComo ainda há muitos destinos, podemos trocar os eixos x e y e rotacionar também os rótulos referentes aos destinos.\n\nvoos2 |&gt;\n  ggplot(\n    aes(x = factor(mes), y = destino, fill = atraso_medio)\n  ) +\n  geom_tile() +\n  scale_fill_viridis_c(option = \"magma\") +\n  labs(\n    x = \"mês\",\n    y = \"destino\",\n    fill = \"atraso médio (min)\"\n  ) +\n  theme(\n    legend.position = \"top\",\n    axis.text.x = element_text(size = 6, angle = 90)\n  ) + \n  coord_flip()\n\n\n\n\n\n\n\n\n2.4.3 Duas variáveis numéricas\n\nEm vez de resumir a distribuição condicional com um boxplot, você poderia usar um polígono de frequência. O que você precisa considerar ao usar cut_width() vs. cut_number()? Como isso afeta a visualização da distribuição 2D de quilate e preco?\n\nResolução: Tanto a função cut_width() quanto a cut_number() permitem discretizar uma variável númerica em categórica.\nA função cut_width() permite gerar grupos de mesma largura.\n\nmenores_diamantes &lt;- diamante |&gt; \n  dplyr::filter(quilate &lt; 3)\n\nggplot(\n  menores_diamantes,\n  aes(x = preco, color = cut_width(quilate, width = 0.25))\n) +\n  geom_freqpoly(binwidth = 500) +\n  labs(\n    x = \"preço (US$)\",\n    y = \"frequência\",\n    color = \"quilate (ct)\"\n  ) +\n  theme_minimal()\n\n\n\n\n\n\n\nJá a função cut_number() gera \\(n\\) grupos com números (aproximadamente) iguais de observações.\n\nggplot(\n  menores_diamantes,\n  aes(x = preco, color = cut_number(quilate, n = 11))\n) +\n  geom_freqpoly(binwidth = 500) +\n  labs(x = \"preço (US$)\", y = \"frequência\", color = \"quilate (ct)\") +\n  theme_minimal()\n\n\n\n\n\n\n\n\nVisualize a distribuição do quilate, particionado por preco.\n\nResolução:\n\nmenores_diamantes &lt;- diamante |&gt; \n  dplyr::filter(quilate &lt; 3)\n\nggplot(menores_diamantes, \n       aes(x = cut_width(preco, 1500, boundary = 0), y = quilate)) + \n  geom_boxplot() +\n  labs(x = \"preço (US$)\", y = \"quilate (ct)\") +\n  coord_flip() +\n  theme_minimal()\n\nggplot(menores_diamantes,\n       aes(x = cut_number(preco, 10), y = quilate)) + \n  geom_boxplot() +\n  labs(x = \"preço (US$)\", y = \"quilate (ct)\") +\n  coord_flip() +\n  theme_minimal() \n\n\n\n\n\n\n\n\n\n\n\n\n\n\nComo a distribuição de preços dos diamantes muito grandes se compara à dos diamantes pequenos? É como você espera ou te surpreende?\n\nResolução: Para diamantes muito grandes, os preços são maiores e, além disso, mais variáveis. Essa maior variabilidade implica que alguns diamantes grandes são extremamente caros, enquanto outros não são tão caros quanto o esperado devido, provavelmente, a influência de outros fatores no preço do diamante (como, por exemplo, a qualidade do corte). Já os diamantes mais pequenos, por outro lado, agrupam-se mais em torno de preços mais baixos, o que sugere uma maior estabilidade nos preços de diamantes pequenos.\n\nCombine duas das técnicas que você aprendeu para visualizar a distribuição combinada de corte, quilate e preço.\n\nResolução:\n\nggplot(diamante,\n       aes(x = corte,\n           y = preco, \n           color = cut_number(quilate, 10))) +\n  geom_boxplot() +\n  labs(x = \"qualidade do corte\", \n       y = \"preço (US$)\",\n       color = \"quilate (ct)\") +\n  theme_minimal() +\n  scale_color_viridis_d()\n\n\n\n\n\n\n\n\nGráficos bidimensionais revelam valores discrepantes que não são visíveis em gráficos unidimensionais. Por exemplo, alguns pontos no gráfico a seguir têm uma combinação incomum de valores x e y, o que torna os pontos discrepantes, embora seus valores x e y pareçam normais quando examinados separadamente. Por que um gráfico de dispersão é uma exibição melhor do que um gráfico agrupado neste caso?\n\n\ndiamante |&gt; \n  filter(x &gt;= 4) |&gt; \n  ggplot(aes(x = x, y = y)) +\n  geom_point() +\n  coord_cartesian(xlim = c(4, 11), ylim = c(4, 11))\n\n\n\n\n\n\n\nResolução: Ao gerar o gráfico de dispersão, torna-se mais óbvios os valores atípicos das relações entre as variáveis. Por exemplo, alguns diamantes podem ter comprimentos e larguras considerados normais individualmente, mas cujas combinações não parecem representar realmente um diamante (como um diamante extremamente longo, mas muito estreito).\n\nEm vez de criar classes de largura igual com cut_width(), poderíamos criar classes que contenham um número aproximadamente igual de pontos com cut_number(). Quais são as vantagens e desvantagens desta abordagem?\n\n\nggplot(menores_diamantes, \n       aes(x = quilate, y = preco)) +\n  geom_boxplot(aes(group = cut_number(quilate, 20)))\n\n\n\n\n\n\n\nResolução: Como é definido um número específico de grupos com um número aproximadamente igual de observações, os grupos (intervalos de valores) podem não ser uniformes, o que pode dificultar a interpretação direta dos valores. Portanto, esta estratégia é boa para comparar distribuições equilibradas, mas os intervalos podem ser irregulares e difíceis de interpretar.",
    "crumbs": [
      "Visualizar",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Análise exploratória de dados</span>"
    ]
  }
]